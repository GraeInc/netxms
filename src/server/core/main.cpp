/*
** NetXMS - Network Management System
** Copyright (C) 2003-2015 NetXMS Team
**
** This program is free software; you can redistribute it and/or modify
** it under the terms of the GNU General Public License as published by
** the Free Software Foundation; either version 2 of the License, or
** (at your option) any later version.
**
** This program is distributed in the hope that it will be useful,
** but WITHOUT ANY WARRANTY; without even the implied warranty of
** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
** GNU General Public License for more details.
**
** You should have received a copy of the GNU General Public License
** along with this program; if not, write to the Free Software
** Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
**
** File: main.cpp
**
**/

#include "nxcore.h"
#include <netxmsdb.h>
#include <netxms_mt.h>
#include <hdlink.h>

#if !defined(_WIN32) && HAVE_READLINE_READLINE_H && HAVE_READLINE && !defined(UNICODE)
#include <readline/readline.h>
#include <readline/history.h>
#define USE_READLINE 1
#endif

#ifdef _WIN32
#include <errno.h>
#include <psapi.h>
#include <conio.h>
#define open	_open
#define write	_write
#define close	_close
#else
#include <signal.h>
#include <sys/wait.h>
#endif

/**
 * Format string to show value of global flag
 */
#define SHOW_FLAG_VALUE(x) _T("  %-38s = %d\n"), _T(#x), (g_flags & x) ? 1 : 0

/**
 * Messages generated by mc.pl (for UNIX version only)
 */
#ifndef _WIN32
extern unsigned int g_dwNumMessages;
extern const TCHAR *g_szMessages[];
#endif

/**
 * Shutdown reasons
 */
#define SHUTDOWN_DEFAULT      0
#define SHUTDOWN_FROM_CONSOLE 1
#define SHUTDOWN_BY_SIGNAL    2

/**
 * Externals
 */
extern Queue g_nodePollerQueue;
extern Queue g_dataCollectionQueue;
extern Queue g_dciCacheLoaderQueue;
extern Queue g_syslogProcessingQueue;
extern Queue g_syslogWriteQueue;
extern ThreadPool *g_pollerThreadPool;
extern ThreadPool *g_schedulerThreadPool;

void InitClientListeners();
void InitMobileDeviceListeners();
void InitCertificates();
void InitUsers();
void CleanupUsers();
void LoadPerfDataStorageDrivers();

void ExecuteScheduledScript(const ScheduledTaskParameters *param);
void MaintenanceModeEnter(const ScheduledTaskParameters *params);
void MaintenanceModeLeave(const ScheduledTaskParameters *params);

#if XMPP_SUPPORTED
void StartXMPPConnector();
void StopXMPPConnector();
#endif

/**
 * Syslog server control
 */
void StartSyslogServer();
void StopSyslogServer();

/**
 * Thread functions
 */
THREAD_RESULT THREAD_CALL HouseKeeper(void *);
THREAD_RESULT THREAD_CALL Syncer(void *);
THREAD_RESULT THREAD_CALL NodePoller(void *);
THREAD_RESULT THREAD_CALL PollManager(void *);
THREAD_RESULT THREAD_CALL EventProcessor(void *);
THREAD_RESULT THREAD_CALL WatchdogThread(void *);
THREAD_RESULT THREAD_CALL ClientListener(void *);
THREAD_RESULT THREAD_CALL ClientListenerIPv6(void *);
THREAD_RESULT THREAD_CALL MobileDeviceListener(void *);
THREAD_RESULT THREAD_CALL MobileDeviceListenerIPv6(void *);
THREAD_RESULT THREAD_CALL ISCListener(void *);
THREAD_RESULT THREAD_CALL LocalAdminListener(void *);
THREAD_RESULT THREAD_CALL SNMPTrapReceiver(void *);
THREAD_RESULT THREAD_CALL BeaconPoller(void *);
THREAD_RESULT THREAD_CALL JobManagerThread(void *);
THREAD_RESULT THREAD_CALL UptimeCalculator(void *);
THREAD_RESULT THREAD_CALL ReportingServerConnector(void *);

/**
 * Global variables
 */
TCHAR NXCORE_EXPORTABLE g_szConfigFile[MAX_PATH] = _T("{search}");
TCHAR NXCORE_EXPORTABLE g_szLogFile[MAX_PATH] = DEFAULT_LOG_FILE;
UINT32 g_dwLogRotationMode = NXLOG_ROTATION_BY_SIZE;
UINT32 g_dwMaxLogSize = 16384 * 1024;
UINT32 g_dwLogHistorySize = 4;
TCHAR g_szDailyLogFileSuffix[64] = _T("");
TCHAR NXCORE_EXPORTABLE g_szDumpDir[MAX_PATH] = DEFAULT_DUMP_DIR;
char g_szCodePage[256] = ICONV_DEFAULT_CODEPAGE;
TCHAR NXCORE_EXPORTABLE g_szListenAddress[MAX_PATH] = _T("*");
#ifndef _WIN32
TCHAR NXCORE_EXPORTABLE g_szPIDFile[MAX_PATH] = _T("/var/run/netxmsd.pid");
#endif
UINT32 g_dwDiscoveryPollingInterval;
UINT32 g_dwStatusPollingInterval;
UINT32 g_dwConfigurationPollingInterval;
UINT32 g_dwRoutingTableUpdateInterval;
UINT32 g_dwTopologyPollingInterval;
UINT32 g_dwConditionPollingInterval;
UINT32 g_instancePollingInterval;
UINT32 g_icmpPingSize;
UINT32 g_icmpPingTimeout = 1500;    // ICMP ping timeout (milliseconds)
UINT32 g_auditFlags;
UINT32 g_slmPollingInterval;
TCHAR NXCORE_EXPORTABLE g_netxmsdDataDir[MAX_PATH] = _T("");
TCHAR NXCORE_EXPORTABLE g_netxmsdLibDir[MAX_PATH] = _T("");
int g_dbSyntax = DB_SYNTAX_UNKNOWN;
UINT32 NXCORE_EXPORTABLE g_processAffinityMask = DEFAULT_AFFINITY_MASK;
UINT64 g_serverId = 0;
RSA *g_pServerKey = NULL;
time_t g_serverStartTime = 0;
UINT32 g_lockTimeout = 60000;   // Default timeout for acquiring mutex
UINT32 g_agentCommandTimeout = 4000;  // Default timeout for requests to agent
UINT32 g_thresholdRepeatInterval = 0;	// Disabled by default
int g_requiredPolls = 1;
DB_DRIVER g_dbDriver = NULL;
ThreadPool *g_mainThreadPool = NULL;
INT16 g_defaultAgentCacheMode = AGENT_CACHE_OFF;

/**
 * Static data
 */
static CONDITION m_condShutdown = INVALID_CONDITION_HANDLE;
static THREAD m_thPollManager = INVALID_THREAD_HANDLE;
static THREAD m_thHouseKeeper = INVALID_THREAD_HANDLE;
static THREAD m_thSyncer = INVALID_THREAD_HANDLE;
static int m_nShutdownReason = SHUTDOWN_DEFAULT;

#ifndef _WIN32
static pthread_t m_signalHandlerThread;
#endif

/**
 * Sleep for specified number of seconds or until system shutdown arrives
 * Function will return TRUE if shutdown event occurs
 *
 * @param seconds seconds to sleep
 * @return true if server is shutting down
 */
bool NXCORE_EXPORTABLE SleepAndCheckForShutdown(int seconds)
{
	return ConditionWait(m_condShutdown, seconds * 1000);
}

/**
 * Disconnect from database (exportable function for startup module)
 */
void NXCORE_EXPORTABLE ShutdownDB()
{
   DBConnectionPoolShutdown();
	DBUnloadDriver(g_dbDriver);
}

/**
 * Check data directory for existence
 */
static BOOL CheckDataDir()
{
	TCHAR szBuffer[MAX_PATH];

	if (_tchdir(g_netxmsdDataDir) == -1)
	{
		nxlog_write(MSG_INVALID_DATA_DIR, EVENTLOG_ERROR_TYPE, "s", g_netxmsdDataDir);
		return FALSE;
	}

#ifdef _WIN32
#define MKDIR(name) _tmkdir(name)
#else
#define MKDIR(name) _tmkdir(name, 0700)
#endif

	// Create directory for package files if it doesn't exist
	_tcscpy(szBuffer, g_netxmsdDataDir);
	_tcscat(szBuffer, DDIR_PACKAGES);
	if (MKDIR(szBuffer) == -1)
		if (errno != EEXIST)
		{
			nxlog_write(MSG_ERROR_CREATING_DATA_DIR, EVENTLOG_ERROR_TYPE, "s", szBuffer);
			return FALSE;
		}

	// Create directory for map background images if it doesn't exist
	_tcscpy(szBuffer, g_netxmsdDataDir);
	_tcscat(szBuffer, DDIR_BACKGROUNDS);
	if (MKDIR(szBuffer) == -1)
		if (errno != EEXIST)
		{
			nxlog_write(MSG_ERROR_CREATING_DATA_DIR, EVENTLOG_ERROR_TYPE, "s", szBuffer);
			return FALSE;
		}

	// Create directory for image library is if does't exists
	_tcscpy(szBuffer, g_netxmsdDataDir);
	_tcscat(szBuffer, DDIR_IMAGES);
	if (MKDIR(szBuffer) == -1)
	{
		if (errno != EEXIST)
		{
			nxlog_write(MSG_ERROR_CREATING_DATA_DIR, EVENTLOG_ERROR_TYPE, "s", szBuffer);
			return FALSE;
		}
	}

	// Create directory for file store if does't exists
	_tcscpy(szBuffer, g_netxmsdDataDir);
	_tcscat(szBuffer, DDIR_FILES);
	if (MKDIR(szBuffer) == -1)
	{
		if (errno != EEXIST)
		{
			nxlog_write(MSG_ERROR_CREATING_DATA_DIR, EVENTLOG_ERROR_TYPE, "s", szBuffer);
			return FALSE;
		}
	}

#undef MKDIR

	return TRUE;
}

/**
 * Load global configuration parameters
 */
static void LoadGlobalConfig()
{
	g_dwDiscoveryPollingInterval = ConfigReadInt(_T("DiscoveryPollingInterval"), 900);
	g_dwStatusPollingInterval = ConfigReadInt(_T("StatusPollingInterval"), 60);
	g_dwConfigurationPollingInterval = ConfigReadInt(_T("ConfigurationPollingInterval"), 3600);
	g_instancePollingInterval = ConfigReadInt(_T("InstancePollingInterval"), 600);
	g_dwRoutingTableUpdateInterval = ConfigReadInt(_T("RoutingTableUpdateInterval"), 300);
	g_dwTopologyPollingInterval = ConfigReadInt(_T("TopologyPollingInterval"), 1800);
	g_dwConditionPollingInterval = ConfigReadInt(_T("ConditionPollingInterval"), 60);
	g_slmPollingInterval = ConfigReadInt(_T("SlmPollingInterval"), 60);
	DCObject::m_defaultPollingInterval = ConfigReadInt(_T("DefaultDCIPollingInterval"), 60);
   DCObject::m_defaultRetentionTime = ConfigReadInt(_T("DefaultDCIRetentionTime"), 30);
   g_defaultAgentCacheMode = (INT16)ConfigReadInt(_T("DefaultAgentCacheMode"), AGENT_CACHE_OFF);
   if ((g_defaultAgentCacheMode != AGENT_CACHE_ON) && (g_defaultAgentCacheMode != AGENT_CACHE_OFF))
   {
      DbgPrintf(1, _T("Invalid value %d of DefaultAgentCacheMode: reset to %d (OFF)"), g_defaultAgentCacheMode, AGENT_CACHE_OFF);
      ConfigWriteInt(_T("DefaultAgentCacheMode"), AGENT_CACHE_OFF, true, true, true);
      g_defaultAgentCacheMode = AGENT_CACHE_OFF;
   }
	if (ConfigReadInt(_T("DeleteEmptySubnets"), 1))
		g_flags |= AF_DELETE_EMPTY_SUBNETS;
	if (ConfigReadInt(_T("EnableSNMPTraps"), 1))
		g_flags |= AF_ENABLE_SNMP_TRAPD;
	if (ConfigReadInt(_T("ProcessTrapsFromUnmanagedNodes"), 0))
		g_flags |= AF_TRAPS_FROM_UNMANAGED_NODES;
	if (ConfigReadInt(_T("EnableZoning"), 0))
		g_flags |= AF_ENABLE_ZONING;
	if (ConfigReadInt(_T("EnableObjectTransactions"), 0))
		g_flags |= AF_ENABLE_OBJECT_TRANSACTIONS;
	if (ConfigReadInt(_T("RunNetworkDiscovery"), 0))
		g_flags |= AF_ENABLE_NETWORK_DISCOVERY;
	if (ConfigReadInt(_T("ActiveNetworkDiscovery"), 0))
		g_flags |= AF_ACTIVE_NETWORK_DISCOVERY;
   if (ConfigReadInt(_T("UseSNMPTrapsForDiscovery"), 0))
      g_flags |= AF_SNMP_TRAP_DISCOVERY;
	if (ConfigReadInt(_T("ResolveNodeNames"), 1))
		g_flags |= AF_RESOLVE_NODE_NAMES;
	if (ConfigReadInt(_T("SyncNodeNamesWithDNS"), 0))
		g_flags |= AF_SYNC_NODE_NAMES_WITH_DNS;
	if (ConfigReadInt(_T("CheckTrustedNodes"), 1))
		g_flags |= AF_CHECK_TRUSTED_NODES;
	if (ConfigReadInt(_T("EnableNXSLContainerFunctions"), 1))
		g_flags |= AF_ENABLE_NXSL_CONTAINER_FUNCS;
   if (ConfigReadInt(_T("UseFQDNForNodeNames"), 1))
      g_flags |= AF_USE_FQDN_FOR_NODE_NAMES;
   if (ConfigReadInt(_T("ApplyDCIFromTemplateToDisabledDCI"), 1))
      g_flags |= AF_APPLY_TO_DISABLED_DCI_FROM_TEMPLATE;
   if (ConfigReadInt(_T("ResolveDNSToIPOnStatusPoll"), 0))
      g_flags |= AF_RESOLVE_IP_FOR_EACH_STATUS_POLL;
   if (ConfigReadInt(_T("CaseInsensitiveLoginNames"), 0))
      g_flags |= AF_CASE_INSENSITIVE_LOGINS;
   if (ConfigReadInt(_T("TrapSourcesInAllZones"), 0))
      g_flags |= AF_TRAP_SOURCES_IN_ALL_ZONES;

   if (g_netxmsdDataDir[0] == 0)
   {
      GetNetXMSDirectory(nxDirData, g_netxmsdDataDir);
      DbgPrintf(1, _T("Data directory set to %s"), g_netxmsdDataDir);
   }
   else
   {
      DbgPrintf(1, _T("Using data directory %s"), g_netxmsdDataDir);
   }

   g_icmpPingTimeout = ConfigReadInt(_T("IcmpPingTimeout"), 1500);
	g_icmpPingSize = ConfigReadInt(_T("IcmpPingSize"), 46);
	g_lockTimeout = ConfigReadInt(_T("LockTimeout"), 60000);
	g_agentCommandTimeout = ConfigReadInt(_T("AgentCommandTimeout"), 4000);
	g_thresholdRepeatInterval = ConfigReadInt(_T("ThresholdRepeatInterval"), 0);
	g_requiredPolls = ConfigReadInt(_T("PollCountForStatusChange"), 1);

	UINT32 snmpTimeout = ConfigReadInt(_T("SNMPRequestTimeout"), 2000);
   SnmpSetDefaultTimeout(snmpTimeout);
}

/**
 * Initialize cryptografic functions
 */
static BOOL InitCryptografy()
{
#ifdef _WITH_ENCRYPTION
	TCHAR szKeyFile[MAX_PATH];
	BOOL bResult = FALSE;
	int fd, iPolicy;
	UINT32 dwLen;
	BYTE *pBufPos, *pKeyBuffer, hash[SHA1_DIGEST_SIZE];

   if (!InitCryptoLib(ConfigReadULong(_T("AllowedCiphers"), 0x7F), DbgPrintf2))
		return FALSE;
   DbgPrintf(4, _T("Supported ciphers: %s"), (const TCHAR *)NXCPGetSupportedCiphersAsText());

   SSL_library_init();
   SSL_load_error_strings();

	_tcscpy(szKeyFile, g_netxmsdDataDir);
	_tcscat(szKeyFile, DFILE_KEYS);
	fd = _topen(szKeyFile, O_RDONLY | O_BINARY);
	g_pServerKey = LoadRSAKeys(szKeyFile);
	if (g_pServerKey == NULL)
	{
		DbgPrintf(1, _T("Generating RSA key pair..."));
		g_pServerKey = RSA_generate_key(NETXMS_RSA_KEYLEN, 17, NULL, 0);
		if (g_pServerKey != NULL)
		{
			fd = _topen(szKeyFile, O_WRONLY | O_BINARY | O_CREAT | O_TRUNC, 0600);
			if (fd != -1)
			{
				dwLen = i2d_RSAPublicKey(g_pServerKey, NULL);
				dwLen += i2d_RSAPrivateKey(g_pServerKey, NULL);
				pKeyBuffer = (BYTE *)malloc(dwLen);

				pBufPos = pKeyBuffer;
				i2d_RSAPublicKey(g_pServerKey, &pBufPos);
				i2d_RSAPrivateKey(g_pServerKey, &pBufPos);
				write(fd, &dwLen, sizeof(UINT32));
				write(fd, pKeyBuffer, dwLen);

				CalculateSHA1Hash(pKeyBuffer, dwLen, hash);
				write(fd, hash, SHA1_DIGEST_SIZE);

				close(fd);
				free(pKeyBuffer);
				bResult = TRUE;
			}
      else
      {
        DbgPrintf(0, _T("Failed to open %s for writing"), szKeyFile);
      }
		}
    else
    {
      DbgPrintf(0, _T("Failed to generate RSA key"));
    }
	}
	else
	{
		bResult = TRUE;
	}

	iPolicy = ConfigReadInt(_T("DefaultEncryptionPolicy"), 1);
	if ((iPolicy < 0) || (iPolicy > 3))
		iPolicy = 1;
	SetAgentDEP(iPolicy);

	return bResult;
#else
	return TRUE;
#endif
}

/**
 * Check if process with given PID exists and is a NetXMS server process
 */
static BOOL IsNetxmsdProcess(UINT32 dwPID)
{
#ifdef _WIN32
	HANDLE hProcess;
	TCHAR szExtModule[MAX_PATH], szIntModule[MAX_PATH];
	BOOL bRet = FALSE;

	hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, dwPID);
	if (hProcess != NULL)
	{
		if ((GetModuleBaseName(hProcess, NULL, szExtModule, MAX_PATH) > 0) &&
				(GetModuleBaseName(GetCurrentProcess(), NULL, szIntModule, MAX_PATH) > 0))
		{
			bRet = !_tcsicmp(szExtModule, szIntModule);
		}
		else
		{
			// Cannot read process name, for safety assume that it's a server process
			bRet = TRUE;
		}
		CloseHandle(hProcess);
	}
	return bRet;
#else
	return (kill((pid_t)dwPID, 0) != -1);
#endif
}

/**
 * Database event handler
 */
static void DBEventHandler(DWORD dwEvent, const WCHAR *pszArg1, const WCHAR *pszArg2, bool connLost, void *userArg)
{
	if (!(g_flags & AF_SERVER_INITIALIZED))
		return;     // Don't try to do anything if server is not ready yet

	switch(dwEvent)
	{
		case DBEVENT_CONNECTION_LOST:
			PostEvent(EVENT_DB_CONNECTION_LOST, g_dwMgmtNode, NULL);
			g_flags |= AF_DB_CONNECTION_LOST;
			NotifyClientSessions(NX_NOTIFY_DBCONN_STATUS, FALSE);
			break;
		case DBEVENT_CONNECTION_RESTORED:
			PostEvent(EVENT_DB_CONNECTION_RESTORED, g_dwMgmtNode, NULL);
			g_flags &= ~AF_DB_CONNECTION_LOST;
			NotifyClientSessions(NX_NOTIFY_DBCONN_STATUS, TRUE);
			break;
		case DBEVENT_QUERY_FAILED:
			PostEvent(EVENT_DB_QUERY_FAILED, g_dwMgmtNode, "uud", pszArg1, pszArg2, connLost ? 1 : 0);
			break;
		default:
			break;
	}
}

/**
 * Send console message to session with open console
 */
static void SendConsoleMessage(ClientSession *session, void *arg)
{
	if (session->isConsoleOpen())
	{
		NXCPMessage msg;

		msg.setCode(CMD_ADM_MESSAGE);
		msg.setField(VID_MESSAGE, (TCHAR *)arg);
		session->postMessage(&msg);
	}
}

/**
 * Console writer
 */
static void LogConsoleWriter(const TCHAR *format, ...)
{
	TCHAR buffer[8192];
	va_list args;

	va_start(args, format);
	_vsntprintf(buffer, 8192, format, args);
	buffer[8191] = 0;
	va_end(args);

	WriteToTerminal(buffer);

	EnumerateClientSessions(SendConsoleMessage, buffer);
}

/**
 * Oracle session init callback
 */
static void OracleSessionInitCallback(DB_HANDLE hdb)
{
   DBQuery(hdb, _T("ALTER SESSION SET DDL_LOCK_TIMEOUT = 60"));
}

/**
 * Server initialization
 */
BOOL NXCORE_EXPORTABLE Initialize()
{
	int i, iDBVersion;
	TCHAR szInfo[256];

	g_serverStartTime = time(NULL);
	srand((unsigned int)g_serverStartTime);

   if (g_netxmsdLibDir[0] == 0)
   {
      GetNetXMSDirectory(nxDirLib, g_netxmsdLibDir);
      DbgPrintf(1, _T("Lib directory set to %s"), g_netxmsdLibDir);
   }

	if (!(g_flags & AF_USE_SYSLOG))
	{
		if (!nxlog_set_rotation_policy((int)g_dwLogRotationMode, (int)g_dwMaxLogSize, (int)g_dwLogHistorySize, g_szDailyLogFileSuffix))
			if (!(g_flags & AF_DAEMON))
				_tprintf(_T("WARNING: cannot set log rotation policy; using default values\n"));
	}
   if (!nxlog_open((g_flags & AF_USE_SYSLOG) ? NETXMSD_SYSLOG_NAME : g_szLogFile,
	                ((g_flags & AF_USE_SYSLOG) ? NXLOG_USE_SYSLOG : 0) |
	                ((g_flags & AF_BACKGROUND_LOG_WRITER) ? NXLOG_BACKGROUND_WRITER : 0) |
                   ((g_flags & AF_DAEMON) ? 0 : NXLOG_PRINT_TO_STDOUT),
                   _T("LIBNXSRV.DLL"),
#ifdef _WIN32
				       0, NULL))
#else
				       g_dwNumMessages, g_szMessages))
#endif
   {
		_ftprintf(stderr, _T("FATAL ERROR: Cannot open log file\n"));
      return FALSE;
   }
	nxlog_set_console_writer(LogConsoleWriter);

	// Set code page
#ifndef _WIN32
	if (SetDefaultCodepage(g_szCodePage))
	{
		DbgPrintf(1, _T("Code page set to %hs"), g_szCodePage);
	}
	else
	{
		nxlog_write(MSG_CODEPAGE_ERROR, EVENTLOG_WARNING_TYPE, "m", g_szCodePage);
	}
#endif

	// Set process affinity mask
	if (g_processAffinityMask != DEFAULT_AFFINITY_MASK)
	{
#ifdef _WIN32
		if (SetProcessAffinityMask(GetCurrentProcess(), g_processAffinityMask))
			DbgPrintf(1, _T("Process affinity mask set to 0x%08X"), g_processAffinityMask);
#else
		nxlog_write(MSG_SET_PROCESS_AFFINITY_NOT_SUPPORTED, EVENTLOG_WARNING_TYPE, NULL);
#endif
	}

#ifdef _WIN32
	WSADATA wsaData;
	int wrc = WSAStartup(MAKEWORD(2, 2), &wsaData);
	if (wrc != 0)
	{
		nxlog_write(MSG_WSASTARTUP_FAILED, EVENTLOG_ERROR_TYPE, "e", wrc);
		return FALSE;
	}
#endif

	InitLocalNetInfo();
   SnmpSetMessageIds(MSG_OID_PARSE_ERROR, MSG_SNMP_UNKNOWN_TYPE, MSG_SNMP_GET_ERROR);

	// Create queue for delayed SQL queries
	g_dbWriterQueue = new Queue(256, 64);
	g_dciDataWriterQueue = new Queue(1024, 1024);
	g_dciRawDataWriterQueue = new Queue(1024, 1024);

	// Initialize database driver and connect to database
	DBSetDebugPrintCallback(DbgPrintf2);
	if (!DBInit(MSG_OTHER, (g_flags & AF_LOG_SQL_ERRORS) ? MSG_SQL_ERROR : 0))
		return FALSE;
	g_dbDriver = DBLoadDriver(g_szDbDriver, g_szDbDrvParams, (g_debugLevel >= 9), DBEventHandler, NULL);
	if (g_dbDriver == NULL)
		return FALSE;

	// Connect to database
	DB_HANDLE hdbBootstrap = NULL;
	TCHAR errorText[DBDRV_MAX_ERROR_TEXT];
	for(i = 0; ; i++)
	{
	   hdbBootstrap = DBConnect(g_dbDriver, g_szDbServer, g_szDbName, g_szDbLogin, g_szDbPassword, g_szDbSchema, errorText);
		if ((hdbBootstrap != NULL) || (i == 5))
			break;
		ThreadSleep(5);
	}
	if (hdbBootstrap == NULL)
	{
		nxlog_write(MSG_DB_CONNFAIL, EVENTLOG_ERROR_TYPE, "s", errorText);
		return FALSE;
	}
	DbgPrintf(1, _T("Successfully connected to database %s@%s"), g_szDbName, g_szDbServer);

	// Check database version
	iDBVersion = DBGetSchemaVersion(hdbBootstrap);
	if (iDBVersion != DB_FORMAT_VERSION)
	{
		nxlog_write(MSG_WRONG_DB_VERSION, EVENTLOG_ERROR_TYPE, "dd", iDBVersion, DB_FORMAT_VERSION);
		DBDisconnect(hdbBootstrap);
		return FALSE;
	}

	// Read database syntax
	g_dbSyntax = DBGetSyntax(hdbBootstrap);
   if (g_dbSyntax == DB_SYNTAX_ORACLE)
   {
      DBSetSessionInitCallback(OracleSessionInitCallback);
   }

	int baseSize = ConfigReadIntEx(hdbBootstrap, _T("DBConnectionPoolBaseSize"), 10);
	int maxSize = ConfigReadIntEx(hdbBootstrap, _T("DBConnectionPoolMaxSize"), 30);
	int cooldownTime = ConfigReadIntEx(hdbBootstrap, _T("DBConnectionPoolCooldownTime"), 300);
	int ttl = ConfigReadIntEx(hdbBootstrap, _T("DBConnectionPoolMaxLifetime"), 14400);

   DBDisconnect(hdbBootstrap);

	if (!DBConnectionPoolStartup(g_dbDriver, g_szDbServer, g_szDbName, g_szDbLogin, g_szDbPassword, g_szDbSchema, baseSize, maxSize, cooldownTime, ttl))
	{
      nxlog_write(MSG_DBCONNPOOL_INIT_FAILED, EVENTLOG_ERROR_TYPE, NULL);
	   return FALSE;
	}

   UINT32 lrt = ConfigReadULong(_T("LongRunningQueryThreshold"), 0);
   if (lrt != 0)
      DBSetLongRunningThreshold(lrt);

	// Read server ID
	MetaDataReadStr(_T("ServerID"), szInfo, 256, _T(""));
	StrStrip(szInfo);
	if (szInfo[0] != 0)
	{
      g_serverId = _tcstoull(szInfo, NULL, 16);
	}
	else
	{
		// Generate new ID
		g_serverId = ((UINT64)time(NULL) << 31) | (UINT64)((UINT32)rand() & 0x7FFFFFFF);
      _sntprintf(szInfo, 256, UINT64X_FMT(_T("016")), g_serverId);
		MetaDataWriteStr(_T("ServerID"), szInfo);
	}
   DbgPrintf(1, _T("Server ID ") UINT64X_FMT(_T("016")), g_serverId);

	// Initialize locks
retry_db_lock:
   InetAddress addr;
	if (!InitLocks(&addr, szInfo))
	{
      if (!addr.isValid())    // Some SQL problems
		{
			nxlog_write(MSG_INIT_LOCKS_FAILED, EVENTLOG_ERROR_TYPE, NULL);
		}
		else     // Database already locked by another server instance
		{
			// Check for lock from crashed/terminated local process
			if (GetLocalIpAddr().equals(addr))
			{
				UINT32 dwPID;

				dwPID = ConfigReadULong(_T("DBLockPID"), 0);
				if (!IsNetxmsdProcess(dwPID) || (dwPID == GetCurrentProcessId()))
				{
					UnlockDB();
					nxlog_write(MSG_DB_LOCK_REMOVED, EVENTLOG_INFORMATION_TYPE, NULL);
					goto retry_db_lock;
				}
			}
			nxlog_write(MSG_DB_LOCKED, EVENTLOG_ERROR_TYPE, "As", &addr, szInfo);
		}
		return FALSE;
	}
	g_flags |= AF_DB_LOCKED;

	// Load global configuration parameters
	LoadGlobalConfig();
   CASReadSettings();
	DbgPrintf(1, _T("Global configuration loaded"));

	// Check data directory
	if (!CheckDataDir())
		return FALSE;

	// Initialize cryptografy
	if (!InitCryptografy())
	{
		nxlog_write(MSG_INIT_CRYPTO_FAILED, EVENTLOG_ERROR_TYPE, NULL);
		return FALSE;
	}

	// Initialize certificate store and CA
	InitCertificates();

	// Create synchronization stuff
	m_condShutdown = ConditionCreate(TRUE);

   // Create thread pools
   DbgPrintf(2, _T("Creating thread pools"));
   ThreadPoolSetDebugCallback(DbgPrintf2);
   g_mainThreadPool = ThreadPoolCreate(8, 256, _T("MAIN"));

	// Setup unique identifiers table
	if (!InitIdTable())
		return FALSE;
	DbgPrintf(2, _T("ID table created"));

	// Update status for unfinished jobs in job history
	DB_HANDLE hdb = DBConnectionPoolAcquireConnection();
	DBQuery(hdb, _T("UPDATE job_history SET status=4,failure_message='Aborted due to server shutdown or crash' WHERE status NOT IN (3,4,5)"));
	DBConnectionPoolReleaseConnection(hdb);

	// Load and compile scripts
	LoadScripts();

	// Initialize watchdog
	WatchdogInit();

	// Load modules
	if (!LoadNetXMSModules())
		return FALSE;	// Mandatory module not loaded

	// Initialize mailer and SMS sender
	InitMailer();
	InitSMSSender();

	// Load users from database
	InitUsers();
	if (!LoadUsers())
	{
		nxlog_write(MSG_ERROR_LOADING_USERS, EVENTLOG_ERROR_TYPE, NULL);
		return FALSE;
	}
	DbgPrintf(2, _T("User accounts loaded"));

	// Initialize audit
	InitAuditLog();

	// Initialize event handling subsystem
	if (!InitEventSubsystem())
		return FALSE;

	// Initialize alarms
	if (!InitAlarmManager())
		return FALSE;

	// Initialize objects infrastructure and load objects from database
	LoadNetworkDeviceDrivers();
	ObjectsInit();
	if (!LoadObjects())
		return FALSE;
	DbgPrintf(1, _T("Objects loaded and initialized"));

	// Initialize situations
	if (!SituationsInit())
		return FALSE;
	DbgPrintf(1, _T("Situations loaded and initialized"));

	// Initialize and load event actions
	if (!InitActions())
	{
		nxlog_write(MSG_ACTION_INIT_ERROR, EVENTLOG_ERROR_TYPE, NULL);
		return FALSE;
	}

   // Initialize helpdesk link
   SetHDLinkEntryPoints(ResolveAlarmByHDRef, TerminateAlarmByHDRef);
   LoadHelpDeskLink();

	// Initialize data collection subsystem
   LoadPerfDataStorageDrivers();
	if (!InitDataCollector())
		return FALSE;

	InitLogAccess();
	FileUploadJob::init();
	InitMappingTables();

	// Check if management node object presented in database
	CheckForMgmtNode();
	if (g_dwMgmtNode == 0)
	{
		nxlog_write(MSG_CANNOT_FIND_SELF, EVENTLOG_ERROR_TYPE, NULL);
		return FALSE;
	}

	// Start threads
	ThreadCreate(WatchdogThread, 0, NULL);
	ThreadCreate(NodePoller, 0, NULL);
	ThreadCreate(JobManagerThread, 0, NULL);
	m_thSyncer = ThreadCreateEx(Syncer, 0, NULL);
	m_thHouseKeeper = ThreadCreateEx(HouseKeeper, 0, NULL);
	m_thPollManager = ThreadCreateEx(PollManager, 0, NULL);

	// Start event processor
	ThreadCreate(EventProcessor, 0, NULL);

	// Start SNMP trapper
	InitTraps();
	if (ConfigReadInt(_T("EnableSNMPTraps"), 1))
		ThreadCreate(SNMPTrapReceiver, 0, NULL);

	// Start built-in syslog daemon
	if (ConfigReadInt(_T("EnableSyslogDaemon"), 0))
	   StartSyslogServer();

	// Start database _T("lazy") write thread
	StartDBWriter();

	// Start local administartive interface listener if required
	if (ConfigReadInt(_T("EnableAdminInterface"), 1))
		ThreadCreate(LocalAdminListener, 0, NULL);

	// Start beacon host poller
	ThreadCreate(BeaconPoller, 0, NULL);

	// Start inter-server communication listener
	if (ConfigReadInt(_T("EnableISCListener"), 0))
		ThreadCreate(ISCListener, 0, NULL);

	// Start reporting server connector
	if (ConfigReadInt(_T("EnableReportingServer"), 0))
		ThreadCreate(ReportingServerConnector, 0, NULL);

   //Start ldap synchronization
   if (ConfigReadInt(_T("LdapSyncInterval"), 0))
		ThreadCreate(SyncLDAPUsers, 0, NULL);

   RegisterSchedulerTaskHandler(_T("Execute.Script"), ExecuteScheduledScript, SYSTEM_ACCESS_SCHEDULE_SCRIPT);
   RegisterSchedulerTaskHandler(_T("Maintenance.Enter"), MaintenanceModeEnter, SYSTEM_ACCESS_SCHEDULE_MAINTENANCE);
   RegisterSchedulerTaskHandler(_T("Maintenance.Leave"), MaintenanceModeLeave, SYSTEM_ACCESS_SCHEDULE_MAINTENANCE);
   InitializeTaskScheduler();

	// Allow clients to connect
	InitClientListeners();
	ThreadCreate(ClientListener, 0, NULL);
#ifdef WITH_IPV6
	ThreadCreate(ClientListenerIPv6, 0, NULL);
#endif

	// Allow mobile devices to connect
	InitMobileDeviceListeners();
	ThreadCreate(MobileDeviceListener, 0, NULL);
#ifdef WITH_IPV6
	ThreadCreate(MobileDeviceListenerIPv6, 0, NULL);
#endif

	// Start uptime calculator for SLM
	ThreadCreate(UptimeCalculator, 0, NULL);

	DbgPrintf(2, _T("LIBDIR: %s"), g_netxmsdLibDir);

	// Call startup functions for the modules
   CALL_ALL_MODULES(pfServerStarted, ());

#if XMPP_SUPPORTED
   if (ConfigReadInt(_T("EnableXMPPConnector"), 1))
   {
      StartXMPPConnector();
   }
#endif

	g_flags |= AF_SERVER_INITIALIZED;
	DbgPrintf(1, _T("Server initialization completed"));
	return TRUE;
}

/**
 * Server shutdown
 */
void NXCORE_EXPORTABLE Shutdown()
{
	// Notify clients
	NotifyClientSessions(NX_NOTIFY_SHUTDOWN, 0);

	nxlog_write(MSG_SERVER_STOPPED, EVENTLOG_INFORMATION_TYPE, NULL);
	g_flags |= AF_SHUTDOWN;     // Set shutdown flag
	ConditionSet(m_condShutdown);

   //shutdown schedule
   CloseTaskScheduler();

   // Stop DCI cache loading thread
   g_dciCacheLoaderQueue.setShutdownMode();

#if XMPP_SUPPORTED
   StopXMPPConnector();
#endif

#ifndef _WIN32
	if (IsStandalone() && (m_nShutdownReason != SHUTDOWN_BY_SIGNAL))
	{
		pthread_kill(m_signalHandlerThread, SIGUSR1);   // Terminate signal handler
	}
#endif

	// Stop event processor
	g_pEventQueue->clear();
	g_pEventQueue->put(INVALID_POINTER_VALUE);

	ShutdownMailer();
	ShutdownSMSSender();

	ThreadSleep(1);     // Give other threads a chance to terminate in a safe way
	DbgPrintf(2, _T("All threads was notified, continue with shutdown"));

	StopSyslogServer();

	// Wait for critical threads
	ThreadJoin(m_thHouseKeeper);
	ThreadJoin(m_thPollManager);
	ThreadJoin(m_thSyncer);

	// Call shutdown functions for the modules
   // CALL_ALL_MODULES cannot be used here because it checks for shutdown flag
   for(UINT32 i = 0; i < g_dwNumModules; i++)
	{
		if (g_pModuleList[i].pfShutdown != NULL)
			g_pModuleList[i].pfShutdown();
	}

   DB_HANDLE hdb = DBConnectionPoolAcquireConnection();
	SaveObjects(hdb);
	DbgPrintf(2, _T("All objects saved to database"));
	SaveUsers(hdb);
	DbgPrintf(2, _T("All users saved to database"));
	DBConnectionPoolReleaseConnection(hdb);

	StopDBWriter();
	DbgPrintf(1, _T("Database writer stopped"));

	CleanupUsers();

	// Remove database lock
	UnlockDB();

	DBConnectionPoolShutdown();
	DBUnloadDriver(g_dbDriver);
	DbgPrintf(1, _T("Database driver unloaded"));

	CleanupActions();
	ShutdownEventSubsystem();
   ShutdownAlarmManager();
	DbgPrintf(1, _T("Event processing stopped"));

   ThreadPoolDestroy(g_mainThreadPool);
   MsgWaitQueue::shutdown();

	delete g_pScriptLibrary;

	nxlog_close();

	// Remove PID file
#ifndef _WIN32
	_tremove(g_szPIDFile);
#endif

	// Terminate process
#ifdef _WIN32
	if (!(g_flags & AF_DAEMON))
		ExitProcess(0);
#else
	exit(0);
#endif
}

/**
 * Fast server shutdown - normally called only by Windows service on system shutdown
 */
void NXCORE_EXPORTABLE FastShutdown()
{
	g_flags |= AF_SHUTDOWN;     // Set shutdown flag
	ConditionSet(m_condShutdown);

	DB_HANDLE hdb = DBConnectionPoolAcquireConnection();
	SaveObjects(hdb);
	DbgPrintf(2, _T("All objects saved to database"));
	SaveUsers(hdb);
	DbgPrintf(2, _T("All users saved to database"));
	DBConnectionPoolReleaseConnection(hdb);

	// Remove database lock first, because we have a chance to lose DB connection
	UnlockDB();

	// Stop database writers
	StopDBWriter();
	DbgPrintf(1, _T("Database writer stopped"));

	nxlog_close();
}

/**
 * Compare given string to command template with abbreviation possibility
 */
static bool IsCommand(const TCHAR *cmdTemplate, TCHAR *pszString, int iMinChars)
{
	int i;

	// Convert given string to uppercase
	_tcsupr(pszString);

	for(i = 0; pszString[i] != 0; i++)
		if (pszString[i] != cmdTemplate[i])
			return false;
	if (i < iMinChars)
		return false;
	return true;
}

/**
 * Dump index callback (by IP address)
 */
static void DumpIndexCallbackByInetAddr(const InetAddress& addr, NetObj *object, void *data)
{
	TCHAR buffer[64];
	ConsolePrintf((CONSOLE_CTX)data, _T("%-40s %p %s [%d]\n"), addr.toString(buffer), object, object->getName(), (int)object->getId());
}

/**
 * Dump index (by IP address)
 */
static void DumpIndex(CONSOLE_CTX pCtx, InetAddressIndex *index)
{
	index->forEach(DumpIndexCallbackByInetAddr, pCtx);
}

/**
 * Dump index callback (by ID)
 */
static void DumpIndexCallbackById(NetObj *object, void *data)
{
	ConsolePrintf((CONSOLE_CTX)data, _T("%08X %p %s\n"), object->getId(), object, object->getName());
}

/**
 * Dump index (by ID)
 */
static void DumpIndex(CONSOLE_CTX pCtx, ObjectIndex *index)
{
	index->forEach(DumpIndexCallbackById, pCtx);
}

/**
 * Process command entered from command line in standalone mode
 * Return TRUE if command was _T("down")
 */
int ProcessConsoleCommand(const TCHAR *pszCmdLine, CONSOLE_CTX pCtx)
{
	const TCHAR *pArg;
	TCHAR szBuffer[256], *eptr;
	int nExitCode = CMD_EXIT_CONTINUE;

	// Get command
	pArg = ExtractWord(pszCmdLine, szBuffer);

	if (IsCommand(_T("DEBUG"), szBuffer, 2))
	{
		// Get argument
		pArg = ExtractWord(pArg, szBuffer);
		int level = (int)_tcstol(szBuffer, &eptr, 0);
		if ((*eptr == 0) && (level >= 0) && (level <= 9))
		{
			g_debugLevel = (UINT32)level;
			ConsolePrintf(pCtx, (level == 0) ? _T("Debug mode turned off\n") : _T("Debug level set to %d\n"), level);
		}
		else if (IsCommand(_T("OFF"), szBuffer, 2))
		{
			g_debugLevel = 0;
			ConsoleWrite(pCtx, _T("Debug mode turned off\n"));
		}
		else
		{
			if (szBuffer[0] == 0)
				ConsoleWrite(pCtx, _T("ERROR: Missing argument\n\n"));
			else
				ConsoleWrite(pCtx, _T("ERROR: Invalid debug level\n\n"));
		}
	}
	else if (IsCommand(_T("DOWN"), szBuffer, 4))
	{
		ConsoleWrite(pCtx, _T("Proceeding with server shutdown...\n"));
		nExitCode = CMD_EXIT_SHUTDOWN;
	}
	else if (IsCommand(_T("DUMP"), szBuffer, 4))
	{
		DumpProcess(pCtx);
	}
	else if (IsCommand(_T("GET"), szBuffer, 3))
	{
		pArg = ExtractWord(pArg, szBuffer);
		if (szBuffer[0] != 0)
		{
			TCHAR value[MAX_CONFIG_VALUE];
			ConfigReadStr(szBuffer, value, MAX_CONFIG_VALUE, _T(""));
			ConsolePrintf(pCtx, _T("%s = %s\n"), szBuffer, value);
		}
		else
		{
			ConsoleWrite(pCtx, _T("Variable name missing\n"));
		}
	}
	else if (IsCommand(_T("RAISE"), szBuffer, 5))
	{
		// Get argument
		pArg = ExtractWord(pArg, szBuffer);

		if (IsCommand(_T("ACCESS"), szBuffer, 6))
		{
			ConsoleWrite(pCtx, _T("Raising exception...\n"));
			char *p = NULL;
			*p = 0;
		}
		else if (IsCommand(_T("BREAKPOINT"), szBuffer, 5))
		{
#ifdef _WIN32
			ConsoleWrite(pCtx, _T("Raising exception...\n"));
			RaiseException(EXCEPTION_BREAKPOINT, 0, 0, NULL);
#else
			ConsoleWrite(pCtx, _T("ERROR: Not supported on current platform\n"));
#endif
		}
		else
		{
			ConsoleWrite(pCtx, _T("Invalid exception name; possible names are:\nACCESS BREAKPOINT\n"));
		}
	}
	else if (IsCommand(_T("EXIT"), szBuffer, 4))
	{
		if ((pCtx->hSocket != -1) || (pCtx->session != NULL))
		{
			ConsoleWrite(pCtx, _T("Closing session...\n"));
			nExitCode = CMD_EXIT_CLOSE_SESSION;
		}
		else
		{
			ConsoleWrite(pCtx, _T("Cannot exit from local server console\n"));
		}
	}
	else if (IsCommand(_T("KILL"), szBuffer, 4))
	{
		pArg = ExtractWord(pArg, szBuffer);
		if (szBuffer[0] != 0)
		{
         int id = _tcstol(szBuffer, &eptr, 10);
         if (*eptr == 0)
         {
            if (KillClientSession(id))
            {
      			ConsoleWrite(pCtx, _T("Session killed\n"));
            }
            else
            {
      			ConsoleWrite(pCtx, _T("Invalid session ID\n"));
            }
         }
         else
         {
   			ConsoleWrite(pCtx, _T("Invalid session ID\n"));
         }
		}
		else
		{
			ConsoleWrite(pCtx, _T("Session ID missing\n"));
		}
   }
	else if (IsCommand(_T("PING"), szBuffer, 4))
	{
		pArg = ExtractWord(pArg, szBuffer);
		if (szBuffer[0] != 0)
		{
         InetAddress addr = InetAddress::parse(szBuffer);
         if (addr.isValid())
         {
            UINT32 rtt;
            UINT32 rc = IcmpPing(addr, 1, 2000, &rtt, 128);
            switch(rc)
            {
               case ICMP_SUCCESS:
                  ConsolePrintf(pCtx, _T("Success, RTT = %d ms\n"), (int)rtt);
                  break;
               case ICMP_UNREACHEABLE:
                  ConsolePrintf(pCtx, _T("Destination unreachable\n"));
                  break;
               case ICMP_TIMEOUT:
                  ConsolePrintf(pCtx, _T("Request timeout\n"));
                  break;
               case ICMP_RAW_SOCK_FAILED:
                  ConsolePrintf(pCtx, _T("Cannot create raw socket\n"));
                  break;
               case ICMP_API_ERROR:
                  ConsolePrintf(pCtx, _T("API error\n"));
                  break;
               default:
                  ConsolePrintf(pCtx, _T("ERROR %d\n"), (int)rc);
                  break;
            }
         }
         else
         {
            ConsoleWrite(pCtx, _T("Invalid IP address\n"));
         }
      }
      else
      {
         ConsoleWrite(pCtx, _T("Usage: PING <address>\n"));
      }
   }
	else if (IsCommand(_T("POLL"), szBuffer, 2))
	{
		pArg = ExtractWord(pArg, szBuffer);
		if (szBuffer[0] != 0)
		{
         int pollType;
         if (IsCommand(_T("CONFIGURATION"), szBuffer, 1))
         {
            pollType = 1;
         }
         else if (IsCommand(_T("STATUS"), szBuffer, 1))
         {
            pollType = 2;
         }
         else if (IsCommand(_T("TOPOLOGY"), szBuffer, 1))
         {
            pollType = 3;
         }
         else
         {
            pollType = 0;
         }

         if (pollType > 0)
         {
      		pArg = ExtractWord(pArg, szBuffer);
			   UINT32 id = _tcstoul(szBuffer, NULL, 0);
			   if (id != 0)
			   {
				   Node *node = (Node *)FindObjectById(id, OBJECT_NODE);
				   if (node != NULL)
				   {
                  switch(pollType)
                  {
                     case 1:
				            node->lockForConfigurationPoll();
                        ThreadPoolExecute(g_pollerThreadPool, node, &Node::configurationPoll, RegisterPoller(POLLER_TYPE_CONFIGURATION, node));
                        break;
                     case 2:
         					node->lockForStatusPoll();
                        ThreadPoolExecute(g_pollerThreadPool, node, &Node::statusPoll, RegisterPoller(POLLER_TYPE_STATUS, node));
                        break;
                     case 3:
         					node->lockForTopologyPoll();
                        ThreadPoolExecute(g_pollerThreadPool, node, &Node::topologyPoll, RegisterPoller(POLLER_TYPE_TOPOLOGY, node));
                        break;
                  }
				   }
				   else
				   {
					   ConsolePrintf(pCtx, _T("ERROR: Node with ID %d does not exist\n\n"), id);
				   }
			   }
			   else
			   {
				   ConsoleWrite(pCtx, _T("ERROR: Invalid or missing node ID\n\n"));
			   }
         }
         else
         {
   			ConsoleWrite(pCtx, _T("Usage POLL [CONFIGURATION|STATUS|TOPOLOGY] <node>\n"));
         }
		}
		else
		{
			ConsoleWrite(pCtx, _T("Usage POLL [CONFIGURATION|STATUS|TOPOLOGY] <node>\n"));
		}
	}
	else if (IsCommand(_T("SET"), szBuffer, 3))
	{
		pArg = ExtractWord(pArg, szBuffer);
		if (szBuffer[0] != 0)
		{
			TCHAR value[256];
			pArg = ExtractWord(pArg, value);
			if (ConfigWriteStr(szBuffer, value, TRUE, TRUE, TRUE))
			{
				ConsolePrintf(pCtx, _T("Configuration variable %s updated\n"), szBuffer);
			}
			else
			{
				ConsolePrintf(pCtx, _T("ERROR: cannot update configuration variable %s\n"), szBuffer);
			}
		}
		else
		{
			ConsolePrintf(pCtx, _T("Variable name missing\n"));
		}
	}
	else if (IsCommand(_T("SHOW"), szBuffer, 2))
	{
		// Get argument
		pArg = ExtractWord(pArg, szBuffer);

		if (IsCommand(_T("COMPONENTS"), szBuffer, 1))
		{
			// Get argument
			pArg = ExtractWord(pArg, szBuffer);
			UINT32 dwNode = _tcstoul(szBuffer, NULL, 0);
			if (dwNode != 0)
			{
				NetObj *pObject = FindObjectById(dwNode);
				if (pObject != NULL)
				{
					if (pObject->getObjectClass() == OBJECT_NODE)
					{
						ComponentTree *components = ((Node *)pObject)->getComponents();
						if (components != NULL)
						{
							components->print(pCtx);
							components->decRefCount();
						}
						else
						{
							ConsoleWrite(pCtx, _T("ERROR: Node does not have physical component information\n\n"));
						}
					}
					else
					{
						ConsoleWrite(pCtx, _T("ERROR: Object is not a node\n\n"));
					}
				}
				else
				{
					ConsolePrintf(pCtx, _T("ERROR: Object with ID %d does not exist\n\n"), dwNode);
				}
			}
			else
			{
				ConsoleWrite(pCtx, _T("ERROR: Invalid or missing node ID\n\n"));
			}
		}
		else if (IsCommand(_T("DBCP"), szBuffer, 4))
		{
         ObjectArray<PoolConnectionInfo> *list = DBConnectionPoolGetConnectionList();
         for(int i = 0; i < list->size(); i++)
         {
            PoolConnectionInfo *c = list->get(i);
            TCHAR accessTime[64];
            struct tm *ltm = localtime(&c->lastAccessTime);
            _tcsftime(accessTime, 64, _T("%d.%b.%Y %H:%M:%S"), ltm);
            ConsolePrintf(pCtx, _T("%p %s %hs:%d\n"), c->handle, accessTime, c->srcFile, c->srcLine);
         }
         ConsolePrintf(pCtx, _T("%d database connections in use\n\n"), list->size());
         delete list;
      }
      else if (IsCommand(_T("DBSTATS"), szBuffer, 3))
      {
         LIBNXDB_PERF_COUNTERS counters;
         DBGetPerfCounters(&counters);
         ConsolePrintf(pCtx, _T("SQL query counters:\n"));
         ConsolePrintf(pCtx, _T("   Total .......... ") INT64_FMT _T("\n"), counters.totalQueries);
         ConsolePrintf(pCtx, _T("   SELECT ......... ") INT64_FMT _T("\n"), counters.selectQueries);
         ConsolePrintf(pCtx, _T("   Non-SELECT ..... ") INT64_FMT _T("\n"), counters.nonSelectQueries);
         ConsolePrintf(pCtx, _T("   Long running ... ") INT64_FMT _T("\n"), counters.longRunningQueries);
         ConsolePrintf(pCtx, _T("   Failed ......... ") INT64_FMT _T("\n"), counters.failedQueries);

         ConsolePrintf(pCtx, _T("Background writer requests:\n"));
         ConsolePrintf(pCtx, _T("   DCI data ....... ") INT64_FMT _T("\n"), g_idataWriteRequests);
         ConsolePrintf(pCtx, _T("   DCI raw data ... ") INT64_FMT _T("\n"), g_rawDataWriteRequests);
         ConsolePrintf(pCtx, _T("   Others ......... ") INT64_FMT _T("\n"), g_otherWriteRequests);
      }
		else if (IsCommand(_T("FDB"), szBuffer, 3))
		{
			// Get argument
			pArg = ExtractWord(pArg, szBuffer);
			UINT32 dwNode = _tcstoul(szBuffer, NULL, 0);
			if (dwNode != 0)
			{
				NetObj *pObject = FindObjectById(dwNode);
				if (pObject != NULL)
				{
					if (pObject->getObjectClass() == OBJECT_NODE)
					{
                  ForwardingDatabase *fdb = ((Node *)pObject)->getSwitchForwardingDatabase();
						if (fdb != NULL)
						{
							fdb->print(pCtx, (Node *)pObject);
							fdb->decRefCount();
						}
						else
						{
							ConsoleWrite(pCtx, _T("ERROR: Node does not have forwarding database information\n\n"));
						}
					}
					else
					{
						ConsoleWrite(pCtx, _T("ERROR: Object is not a node\n\n"));
					}
				}
				else
				{
					ConsolePrintf(pCtx, _T("ERROR: Object with ID %d does not exist\n\n"), dwNode);
				}
			}
			else
			{
				ConsoleWrite(pCtx, _T("ERROR: Invalid or missing node ID\n\n"));
			}
		}
		else if (IsCommand(_T("FLAGS"), szBuffer, 1))
		{
         ConsolePrintf(pCtx, _T("Flags: 0x") UINT64X_FMT(_T("016")) _T("\n"), g_flags);
			ConsolePrintf(pCtx, SHOW_FLAG_VALUE(AF_DAEMON));
			ConsolePrintf(pCtx, SHOW_FLAG_VALUE(AF_USE_SYSLOG));
			ConsolePrintf(pCtx, SHOW_FLAG_VALUE(AF_ENABLE_NETWORK_DISCOVERY));
			ConsolePrintf(pCtx, SHOW_FLAG_VALUE(AF_ACTIVE_NETWORK_DISCOVERY));
			ConsolePrintf(pCtx, SHOW_FLAG_VALUE(AF_LOG_SQL_ERRORS));
			ConsolePrintf(pCtx, SHOW_FLAG_VALUE(AF_DELETE_EMPTY_SUBNETS));
			ConsolePrintf(pCtx, SHOW_FLAG_VALUE(AF_ENABLE_SNMP_TRAPD));
			ConsolePrintf(pCtx, SHOW_FLAG_VALUE(AF_ENABLE_ZONING));
			ConsolePrintf(pCtx, SHOW_FLAG_VALUE(AF_SYNC_NODE_NAMES_WITH_DNS));
			ConsolePrintf(pCtx, SHOW_FLAG_VALUE(AF_CHECK_TRUSTED_NODES));
			ConsolePrintf(pCtx, SHOW_FLAG_VALUE(AF_ENABLE_NXSL_CONTAINER_FUNCS));
			ConsolePrintf(pCtx, SHOW_FLAG_VALUE(AF_USE_FQDN_FOR_NODE_NAMES));
			ConsolePrintf(pCtx, SHOW_FLAG_VALUE(AF_APPLY_TO_DISABLED_DCI_FROM_TEMPLATE));
			ConsolePrintf(pCtx, SHOW_FLAG_VALUE(AF_DEBUG_CONSOLE_DISABLED));
			ConsolePrintf(pCtx, SHOW_FLAG_VALUE(AF_ENABLE_OBJECT_TRANSACTIONS));
			ConsolePrintf(pCtx, SHOW_FLAG_VALUE(AF_WRITE_FULL_DUMP));
			ConsolePrintf(pCtx, SHOW_FLAG_VALUE(AF_RESOLVE_NODE_NAMES));
			ConsolePrintf(pCtx, SHOW_FLAG_VALUE(AF_CATCH_EXCEPTIONS));
			ConsolePrintf(pCtx, SHOW_FLAG_VALUE(AF_HELPDESK_LINK_ACTIVE));
			ConsolePrintf(pCtx, SHOW_FLAG_VALUE(AF_DB_LOCKED));
			ConsolePrintf(pCtx, SHOW_FLAG_VALUE(AF_DB_CONNECTION_LOST));
			ConsolePrintf(pCtx, SHOW_FLAG_VALUE(AF_NO_NETWORK_CONNECTIVITY));
			ConsolePrintf(pCtx, SHOW_FLAG_VALUE(AF_EVENT_STORM_DETECTED));
			ConsolePrintf(pCtx, SHOW_FLAG_VALUE(AF_SNMP_TRAP_DISCOVERY));
			ConsolePrintf(pCtx, SHOW_FLAG_VALUE(AF_TRAPS_FROM_UNMANAGED_NODES));
			ConsolePrintf(pCtx, SHOW_FLAG_VALUE(AF_RESOLVE_IP_FOR_EACH_STATUS_POLL));
			ConsolePrintf(pCtx, SHOW_FLAG_VALUE(AF_PERFDATA_STORAGE_DRIVER_LOADED));
			ConsolePrintf(pCtx, SHOW_FLAG_VALUE(AF_BACKGROUND_LOG_WRITER));
         ConsolePrintf(pCtx, SHOW_FLAG_VALUE(AF_CASE_INSENSITIVE_LOGINS));
         ConsolePrintf(pCtx, SHOW_FLAG_VALUE(AF_TRAP_SOURCES_IN_ALL_ZONES));
			ConsolePrintf(pCtx, SHOW_FLAG_VALUE(AF_SERVER_INITIALIZED));
			ConsolePrintf(pCtx, SHOW_FLAG_VALUE(AF_SHUTDOWN));
			ConsolePrintf(pCtx, _T("\n"));
		}
		else if (IsCommand(_T("HEAP"), szBuffer, 1))
		{
         TCHAR *text = GetHeapInfo();
         if (text != NULL)
         {
            ConsoleWrite(pCtx, text);
            ConsoleWrite(pCtx, _T("\n"));
            free(text);
         }
         else
         {
            ConsoleWrite(pCtx, _T("Error reading heap information\n"));
         }
      }
		else if (IsCommand(_T("INDEX"), szBuffer, 1))
		{
			// Get argument
			pArg = ExtractWord(pArg, szBuffer);

			if (IsCommand(_T("CONDITION"), szBuffer, 1))
			{
				DumpIndex(pCtx, &g_idxConditionById);
			}
			else if (IsCommand(_T("ID"), szBuffer, 2))
			{
				DumpIndex(pCtx, &g_idxObjectById);
			}
			else if (IsCommand(_T("INTERFACE"), szBuffer, 2))
			{
				DumpIndex(pCtx, &g_idxInterfaceByAddr);
			}
			else if (IsCommand(_T("NODEADDR"), szBuffer, 5))
			{
				DumpIndex(pCtx, &g_idxNodeByAddr);
			}
			else if (IsCommand(_T("NODEID"), szBuffer, 5))
			{
				DumpIndex(pCtx, &g_idxNodeById);
			}
			else if (IsCommand(_T("SUBNET"), szBuffer, 1))
			{
				DumpIndex(pCtx, &g_idxSubnetByAddr);
			}
			else if (IsCommand(_T("ZONE"), szBuffer, 1))
			{
				DumpIndex(pCtx, &g_idxZoneByGUID);
			}
			else
			{
				if (szBuffer[0] == 0)
					ConsoleWrite(pCtx, _T("ERROR: Missing index name\n")
							             _T("Valid names are: CONDITION, ID, INTERFACE, NODEADDR, NODEID, SUBNET, ZONE\n\n"));
				else
					ConsoleWrite(pCtx, _T("ERROR: Invalid index name\n\n"));
			}
		}
		else if (IsCommand(_T("MODULES"), szBuffer, 3))
		{
         ConsoleWrite(pCtx, _T("Loaded server modules:\n"));
         for(UINT32 i = 0; i < g_dwNumModules; i++)
         {
            ConsolePrintf(pCtx, _T("   %s\n"), g_pModuleList[i].szName);
         }
         ConsolePrintf(pCtx, _T("%d modules loaded\n"), g_dwNumModules);
		}
		else if (IsCommand(_T("MSGWQ"), szBuffer, 2))
		{
         String text = MsgWaitQueue::getDiagInfo();
         ConsoleWrite(pCtx, text);
         ConsoleWrite(pCtx, _T("\n"));
      }
		else if (IsCommand(_T("OBJECTS"), szBuffer, 1))
		{
			// Get filter
			pArg = ExtractWord(pArg, szBuffer);
         StrStrip(szBuffer);
         DumpObjects(pCtx, (szBuffer[0] != 0) ? szBuffer : NULL);
		}
		else if (IsCommand(_T("POLLERS"), szBuffer, 1))
		{
			ShowPollers(pCtx);
		}
		else if (IsCommand(_T("QUEUES"), szBuffer, 1))
		{
			ShowQueueStats(pCtx, &g_dataCollectionQueue, _T("Data collector"));
			ShowQueueStats(pCtx, &g_dciCacheLoaderQueue, _T("DCI cache loader"));
			ShowQueueStats(pCtx, g_dbWriterQueue, _T("Database writer"));
			ShowQueueStats(pCtx, g_dciDataWriterQueue, _T("Database writer (IData)"));
			ShowQueueStats(pCtx, g_dciRawDataWriterQueue, _T("Database writer (raw DCI values)"));
			ShowQueueStats(pCtx, g_pEventQueue, _T("Event processor"));
			ShowQueueStats(pCtx, &g_nodePollerQueue, _T("Node poller"));
			ShowQueueStats(pCtx, &g_syslogProcessingQueue, _T("Syslog processing"));
			ShowQueueStats(pCtx, &g_syslogWriteQueue, _T("Syslog writer"));
			ConsolePrintf(pCtx, _T("\n"));
		}
		else if (IsCommand(_T("ROUTING-TABLE"), szBuffer, 1))
		{
			UINT32 dwNode;
			NetObj *pObject;

			pArg = ExtractWord(pArg, szBuffer);
			dwNode = _tcstoul(szBuffer, NULL, 0);
			if (dwNode != 0)
			{
				pObject = FindObjectById(dwNode);
				if (pObject != NULL)
				{
					if (pObject->getObjectClass() == OBJECT_NODE)
					{
						ROUTING_TABLE *pRT;
						TCHAR szIpAddr[16];
						int i;

						ConsolePrintf(pCtx, _T("Routing table for node %s:\n\n"), pObject->getName());
						pRT = ((Node *)pObject)->getCachedRoutingTable();
						if (pRT != NULL)
						{
							for(i = 0; i < pRT->iNumEntries; i++)
							{
								_sntprintf(szBuffer, 256, _T("%s/%d"), IpToStr(pRT->pRoutes[i].dwDestAddr, szIpAddr),
										     BitsInMask(pRT->pRoutes[i].dwDestMask));
								ConsolePrintf(pCtx, _T("%-18s %-15s %-6d %d\n"), szBuffer,
										        IpToStr(pRT->pRoutes[i].dwNextHop, szIpAddr),
										        pRT->pRoutes[i].dwIfIndex, pRT->pRoutes[i].dwRouteType);
							}
							ConsoleWrite(pCtx, _T("\n"));
						}
						else
						{
							ConsoleWrite(pCtx, _T("Node doesn't have cached routing table\n\n"));
						}
					}
					else
					{
						ConsoleWrite(pCtx, _T("ERROR: Object is not a node\n\n"));
					}
				}
				else
				{
					ConsolePrintf(pCtx, _T("ERROR: Object with ID %d does not exist\n\n"), dwNode);
				}
			}
			else
			{
				ConsoleWrite(pCtx, _T("ERROR: Invalid or missing node ID\n\n"));
			}
		}
		else if (IsCommand(_T("SESSIONS"), szBuffer, 2))
		{
			ConsoleWrite(pCtx, _T("\x1b[1mCLIENT SESSIONS\x1b[0m\n============================================================\n"));
			DumpClientSessions(pCtx);
			ConsoleWrite(pCtx, _T("\n\x1b[1mMOBILE DEVICE SESSIONS\x1b[0m\n============================================================\n"));
			DumpMobileDeviceSessions(pCtx);
		}
		else if (IsCommand(_T("STATS"), szBuffer, 2))
		{
			ShowServerStats(pCtx);
		}
		else if (IsCommand(_T("THREADS"), szBuffer, 2))
		{
			ShowThreadPool(pCtx, g_mainThreadPool);
			ShowThreadPool(pCtx, g_pollerThreadPool);
			ShowThreadPool(pCtx, g_schedulerThreadPool);
		}
		else if (IsCommand(_T("TOPOLOGY"), szBuffer, 1))
		{
			pArg = ExtractWord(pArg, szBuffer);
			UINT32 nodeId = _tcstoul(szBuffer, NULL, 0);
			if (nodeId != 0)
			{
				Node *node = (Node *)FindObjectById(nodeId, OBJECT_NODE);
				if (node != NULL)
				{
            	LinkLayerNeighbors *nbs = BuildLinkLayerNeighborList(node);
               if (nbs != NULL)
               {
                  ConsolePrintf(pCtx, _T("Proto   | PtP | ifLocal | ifRemote | Peer\n")
                                      _T("--------+-----+---------+----------+------------------------------------\n"));
                  for(int i = 0; i < nbs->size(); i++)
                  {
            			LL_NEIGHBOR_INFO *ni = nbs->getConnection(i);
                     TCHAR peer[256];
                     if (ni->objectId != 0)
                     {
                        NetObj *object = FindObjectById(ni->objectId);
                        if (object != NULL)
                           _sntprintf(peer, 256, _T("%s [%d]"), object->getName(), ni->objectId);
                        else
                           _sntprintf(peer, 256, _T("[%d]"), ni->objectId);
                     }
                     else
                     {
                        peer[0] = 0;
                     }
                     ConsolePrintf(pCtx, _T("%-7s | %c   | %7d | %7d | %s\n"),
                        GetLinkLayerProtocolName(ni->protocol), ni->isPtToPt ? _T('Y') : _T('N'), ni->ifLocal, ni->ifRemote, peer);
                  }
                  nbs->decRefCount();
               }
               else
               {
   					ConsoleWrite(pCtx, _T("ERROR: call to BuildLinkLayerNeighborList failed\n\n"));
               }
				}
				else
				{
					ConsolePrintf(pCtx, _T("ERROR: Node with ID %d does not exist\n\n"), nodeId);
				}
			}
			else
			{
				ConsoleWrite(pCtx, _T("ERROR: Invalid or missing node ID\n\n"));
			}
		}
		else if (IsCommand(_T("USERS"), szBuffer, 1))
		{
			DumpUsers(pCtx);
		}
		else if (IsCommand(_T("VLANS"), szBuffer, 1))
		{
			UINT32 dwNode;
			NetObj *pObject;

			pArg = ExtractWord(pArg, szBuffer);
			dwNode = _tcstoul(szBuffer, NULL, 0);
			if (dwNode != 0)
			{
				pObject = FindObjectById(dwNode);
				if (pObject != NULL)
				{
					if (pObject->getObjectClass() == OBJECT_NODE)
					{
						VlanList *vlans = ((Node *)pObject)->getVlans();
						if (vlans != NULL)
						{
							ConsoleWrite(pCtx, _T("\x1b[1mVLAN\x1b[0m | \x1b[1mName\x1b[0m             | \x1b[1mPorts\x1b[0m\n")
								                _T("-----+------------------+-----------------------------------------------------------------\n"));
							for(int i = 0; i < vlans->size(); i++)
							{
								VlanInfo *vlan = vlans->get(i);
								ConsolePrintf(pCtx, _T("%4d | %-16s |"), vlan->getVlanId(), vlan->getName());
								for(int j = 0; j < vlan->getNumPorts(); j++)
									ConsolePrintf(pCtx, _T(" %d.%d"), (int)(vlan->getPorts()[j] >> 16), (int)(vlan->getPorts()[j] & 0xFFFF));
								ConsolePrintf(pCtx, _T("\n"));
							}
							ConsolePrintf(pCtx, _T("\n"));
							vlans->decRefCount();
						}
						else
						{
							ConsoleWrite(pCtx, _T("\x1b[31mNode doesn't have VLAN information\x1b[0m\n\n"));
						}
					}
					else
					{
						ConsoleWrite(pCtx, _T("\x1b[31mERROR: Object is not a node\x1b[0m\n\n"));
					}
				}
				else
				{
					ConsolePrintf(pCtx, _T("\x1b[31mERROR: Object with ID %d does not exist\x1b[0m\n\n"), dwNode);
				}
			}
			else
			{
				ConsoleWrite(pCtx, _T("\x1b[31mERROR: Invalid or missing node ID\x1b[0m\n\n"));
			}
		}
		else if (IsCommand(_T("WATCHDOG"), szBuffer, 1))
		{
			WatchdogPrintStatus(pCtx);
			ConsoleWrite(pCtx, _T("\n"));
		}
		else
		{
			if (szBuffer[0] == 0)
				ConsoleWrite(pCtx, _T("ERROR: Missing subcommand\n\n"));
			else
				ConsoleWrite(pCtx, _T("ERROR: Invalid SHOW subcommand\n\n"));
		}
	}
	else if (IsCommand(_T("EXEC"), szBuffer, 3))
	{
		pArg = ExtractWord(pArg, szBuffer);

		bool libraryLocked = true;
      bool destroyCompiledScript = false;
		g_pScriptLibrary->lock();

		NXSL_Program *compiledScript = g_pScriptLibrary->findScript(szBuffer);
		if (compiledScript == NULL)
		{
			g_pScriptLibrary->unlock();
			libraryLocked = false;
         destroyCompiledScript = true;
			char *script;
			UINT32 fileSize;
			if ((script = (char *)LoadFile(szBuffer, &fileSize)) != NULL)
			{
				const int errorMsgLen = 512;
				TCHAR errorMsg[errorMsgLen];
#ifdef UNICODE
				WCHAR *wscript = WideStringFromMBString(script);
				compiledScript = NXSLCompile(wscript, errorMsg, errorMsgLen, NULL);
				free(wscript);
#else
				compiledScript = NXSLCompile(script, errorMsg, errorMsgLen, NULL);
#endif
				free(script);
				if (compiledScript == NULL)
				{
					ConsolePrintf(pCtx, _T("ERROR: Script compilation error: %s\n\n"), errorMsg);
				}
			}
			else
			{
				ConsolePrintf(pCtx, _T("ERROR: Script \"%s\" not found\n\n"), szBuffer);
			}
		}

		if (compiledScript != NULL)
		{
			NXSL_ServerEnv *pEnv = new NXSL_ServerEnv;
			pEnv->setConsole(pCtx);

         NXSL_VM *vm = new NXSL_VM(pEnv);
         if (vm->load(compiledScript))
         {
            if (libraryLocked)
            {
      			g_pScriptLibrary->unlock();
               libraryLocked = false;
            }

			   NXSL_Value *argv[32];
			   int argc = 0;
			   while(argc < 32)
			   {
				   pArg = ExtractWord(pArg, szBuffer);
				   if (szBuffer[0] == 0)
					   break;
				   argv[argc++] = new NXSL_Value(szBuffer);
			   }

			   if (vm->run(argc, argv))
			   {
				   NXSL_Value *pValue = vm->getResult();
				   int retCode = pValue->getValueAsInt32();
				   ConsolePrintf(pCtx, _T("INFO: Script finished with rc=%d\n\n"), retCode);
			   }
			   else
			   {
				   ConsolePrintf(pCtx, _T("ERROR: Script finished with error: %s\n\n"), vm->getErrorText());
			   }
         }
         else
         {
			   ConsolePrintf(pCtx, _T("ERROR: VM creation failed: %s\n\n"), vm->getErrorText());
         }
         delete vm;
         if (destroyCompiledScript)
            delete compiledScript;
		}
		if (libraryLocked)
			g_pScriptLibrary->unlock();
	}
	else if (IsCommand(_T("TRACE"), szBuffer, 1))
	{
		UINT32 dwNode1, dwNode2;
		NetObj *pObject1, *pObject2;
		NetworkPath *pTrace;
		TCHAR szNextHop[16];
		int i;

		// Get arguments
		pArg = ExtractWord(pArg, szBuffer);
		dwNode1 = _tcstoul(szBuffer, NULL, 0);

		pArg = ExtractWord(pArg, szBuffer);
		dwNode2 = _tcstoul(szBuffer, NULL, 0);

		if ((dwNode1 != 0) && (dwNode2 != 0))
		{
			pObject1 = FindObjectById(dwNode1);
			if (pObject1 == NULL)
			{
				ConsolePrintf(pCtx, _T("ERROR: Object with ID %d does not exist\n\n"), dwNode1);
			}
			else
			{
				pObject2 = FindObjectById(dwNode2);
				if (pObject2 == NULL)
				{
					ConsolePrintf(pCtx, _T("ERROR: Object with ID %d does not exist\n\n"), dwNode2);
				}
				else
				{
					if ((pObject1->getObjectClass() == OBJECT_NODE) && (pObject2->getObjectClass() == OBJECT_NODE))
					{
						pTrace = TraceRoute((Node *)pObject1, (Node *)pObject2);
						if (pTrace != NULL)
						{
                     TCHAR sourceIp[32];
							ConsolePrintf(pCtx, _T("Trace from %s to %s (%d hops, %s, source IP %s):\n"),
									pObject1->getName(), pObject2->getName(), pTrace->getHopCount(),
									pTrace->isComplete() ? _T("complete") : _T("incomplete"),
                           pTrace->getSourceAddress().toString(sourceIp));
 							for(i = 0; i < pTrace->getHopCount(); i++)
							{
								HOP_INFO *hop = pTrace->getHopInfo(i);
								ConsolePrintf(pCtx, _T("[%d] %s %s %s %d\n"),
										hop->object->getId(),
										hop->object->getName(),
										hop->nextHop.toString(szNextHop),
										hop->isVpn ? _T("VPN Connector ID:") : _T("Interface Index: "),
										hop->ifIndex);
							}
							delete pTrace;
							ConsolePrintf(pCtx, _T("\n"));
						}
						else
						{
							ConsoleWrite(pCtx, _T("ERROR: Call to TraceRoute() failed\n\n"));
						}
					}
					else
					{
						ConsoleWrite(pCtx, _T("ERROR: Object is not a node\n\n"));
					}
				}
			}
		}
		else
		{
			ConsoleWrite(pCtx, _T("ERROR: Invalid or missing node id(s)\n\n"));
		}
	}
   else if (IsCommand(_T("LDAPSYNC"), szBuffer, 4))
   {
      LDAPConnection conn;
      conn.syncUsers();
   }
   else if (IsCommand(_T("AT"), szBuffer, 2))
   {
      pArg = ExtractWord(pArg, szBuffer);
      if (szBuffer[0] == _T('+'))
      {
         int offset = _tcstoul(&szBuffer[1], NULL, 0);
         AddOneTimeScheduledTask(_T("Execute.Script"), time(NULL) + offset, pArg, 0, 0, SYSTEM_ACCESS_FULL);//TODO: change to correct user
      }
      else
      {
         AddScheduledTask(_T("Execute.Script"), szBuffer, pArg, 0, 0, SYSTEM_ACCESS_FULL); //TODO: change to correct user
      }
   }
	else if (IsCommand(_T("HELP"), szBuffer, 2) || IsCommand(_T("?"), szBuffer, 1))
	{
		ConsoleWrite(pCtx,
            _T("Valid commands are:\n")
				_T("   at +<seconds>|<schedule> <script> [<parameters>]\n")
            _T("                             - Schedule script execution task\n")
				_T("   debug [<level>|off]       - Set debug level (valid range is 0..9)\n")
				_T("   down                      - Shutdown NetXMS server\n")
				_T("   exec <script> [<params>]  - Executes NXSL script from script library\n")
				_T("   exit                      - Exit from remote session\n")
            _T("   kill <session>            - Kill client session\n")
				_T("   get <variable>            - Get value of server configuration variable\n")
				_T("   help                      - Display this help\n")
				_T("   ldapsync                  - Synchronize ldap users with local user database\n")
            _T("   ping <address>            - Send ICMP echo request to given IP address\n")
            _T("   poll <type> <node>        - Initiate node poll\n")
				_T("   raise <exception>         - Raise exception\n")
				_T("   set <variable> <value>    - Set value of server configuration variable\n")
				_T("   show components <node>    - Show physical components of given node\n")
            _T("   show dbcp                 - Show active sessions in database connection pool\n")
            _T("   show dbstats              - Show DB library statistics\n")
				_T("   show fdb <node>           - Show forwarding database for node\n")
				_T("   show flags                - Show internal server flags\n")
            _T("   show heap                 - Show heap information\n")
				_T("   show index <index>        - Show internal index\n")
				_T("   show modules              - Show loaded server modules\n")
            _T("   show msgwq                - Show message wait queues information\n")
				_T("   show objects [<filter>]   - Dump network objects to screen\n")
				_T("   show pollers              - Show poller threads state information\n")
				_T("   show queues               - Show internal queues statistics\n")
				_T("   show routing-table <node> - Show cached routing table for node\n")
				_T("   show sessions             - Show active client sessions\n")
				_T("   show stats                - Show server statistics\n")
				_T("   show topology <node>      - Collect and show link layer topology for node\n")
				_T("   show users                - Show users\n")
				_T("   show vlans <node>         - Show cached VLAN information for node\n")
				_T("   show watchdog             - Display watchdog information\n")
				_T("   trace <node1> <node2>     - Show network path trace between two nodes\n")
				_T("\nAlmost all commands can be abbreviated to 2 or 3 characters\n")
				_T("\n"));
	}
   else
	{
		ConsoleWrite(pCtx, _T("UNKNOWN COMMAND\n\n"));
	}

	return nExitCode;
}

/**
 * Signal handler for UNIX platforms
 */
#ifndef _WIN32

void SignalHandlerStub(int nSignal)
{
	// should be unused, but JIC...
	if (nSignal == SIGCHLD)
	{
		while (waitpid(-1, NULL, WNOHANG) > 0)
			;
	}
}

THREAD_RESULT NXCORE_EXPORTABLE THREAD_CALL SignalHandler(void *pArg)
{
	sigset_t signals;
	int nSignal;
	BOOL bCallShutdown = FALSE;

	m_signalHandlerThread = pthread_self();

	// default for SIGCHLD: ignore
	signal(SIGCHLD, &SignalHandlerStub);

	sigemptyset(&signals);
	sigaddset(&signals, SIGTERM);
	sigaddset(&signals, SIGINT);
	sigaddset(&signals, SIGSEGV);
	sigaddset(&signals, SIGCHLD);
	sigaddset(&signals, SIGHUP);
	sigaddset(&signals, SIGUSR1);
	sigaddset(&signals, SIGUSR2);
#if !defined(__sun) && !defined(_AIX) && !defined(__hpux)
	sigaddset(&signals, SIGPIPE);
#endif

	sigprocmask(SIG_BLOCK, &signals, NULL);

	while(1)
	{
		if (sigwait(&signals, &nSignal) == 0)
		{
			switch(nSignal)
			{
				case SIGTERM:
				case SIGINT:
					m_nShutdownReason = SHUTDOWN_BY_SIGNAL;
					if (IsStandalone())
						bCallShutdown = TRUE;
					ConditionSet(m_condShutdown);
					goto stop_handler;
				case SIGSEGV:
					abort();
					break;
				case SIGCHLD:
					while (waitpid(-1, NULL, WNOHANG) > 0)
						;
					break;
				case SIGUSR1:
					if (g_flags & AF_SHUTDOWN)
						goto stop_handler;
					break;
				default:
					break;
			}
		}
		else
		{
			ThreadSleepMs(100);
		}
	}

stop_handler:
	sigprocmask(SIG_UNBLOCK, &signals, NULL);
	if (bCallShutdown)
		Shutdown();
	return THREAD_OK;
}

#endif

/**
 * Common main()
 */
THREAD_RESULT NXCORE_EXPORTABLE THREAD_CALL Main(void *pArg)
{
	nxlog_write(MSG_SERVER_STARTED, EVENTLOG_INFORMATION_TYPE, NULL);

	if (IsStandalone())
   {
      if (!(g_flags & AF_DEBUG_CONSOLE_DISABLED))
	   {
		   char *ptr, szCommand[256];
		   struct __console_ctx ctx;
#ifdef UNICODE
   		WCHAR wcCommand[256];
#endif

		   ctx.hSocket = -1;
		   ctx.socketMutex = INVALID_MUTEX_HANDLE;
		   ctx.pMsg = NULL;
		   ctx.session = NULL;
         ctx.output = NULL;
		   WriteToTerminal(_T("\nNetXMS Server V") NETXMS_VERSION_STRING _T(" Build ") NETXMS_VERSION_BUILD_STRING IS_UNICODE_BUILD_STRING _T(" Ready\n")
				             _T("Enter \"\x1b[1mhelp\x1b[0m\" for command list or \"\x1b[1mdown\x1b[0m\" for server shutdown\n")
				             _T("System Console\n\n"));

#if USE_READLINE
		   // Initialize readline library if we use it
		   rl_bind_key('\t', RL_INSERT_CAST rl_insert);
#endif

		   while(1)
		   {
#if USE_READLINE
   			ptr = readline("\x1b[33mnetxmsd:\x1b[0m ");
#else
			   WriteToTerminal(_T("\x1b[33mnetxmsd:\x1b[0m "));
			   fflush(stdout);
			   if (fgets(szCommand, 255, stdin) == NULL)
				   break;   // Error reading stdin
			   ptr = strchr(szCommand, '\n');
			   if (ptr != NULL)
				   *ptr = 0;
			   ptr = szCommand;
#endif

			   if (ptr != NULL)
			   {
#ifdef UNICODE
				   MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, ptr, -1, wcCommand, 256);
				   wcCommand[255] = 0;
				   StrStrip(wcCommand);
				   if (wcCommand[0] != 0)
				   {
					   if (ProcessConsoleCommand(wcCommand, &ctx) == CMD_EXIT_SHUTDOWN)
#else
				   StrStrip(ptr);
				   if (*ptr != 0)
				   {
					   if (ProcessConsoleCommand(ptr, &ctx) == CMD_EXIT_SHUTDOWN)
#endif
						   break;
#if USE_READLINE
					   add_history(ptr);
#endif
				   }
#if USE_READLINE
				   free(ptr);
#endif
			   }
			   else
			   {
				   _tprintf(_T("\n"));
			   }
		   }

#if USE_READLINE
   		free(ptr);
#endif
		   m_nShutdownReason = SHUTDOWN_FROM_CONSOLE;
		   Shutdown();
      }
      else
      {
         // standalone with debug console disabled
#ifdef _WIN32
         _tprintf(_T("Server running. Press ESC to shutdown.\n"));
         while(1)
         {
            if (_getch() == 27)
               break;
         }
         _tprintf(_T("Server shutting down...\n"));
         Shutdown();
#else
         _tprintf(_T("Server running. Press Ctrl+C to shutdown.\n"));
         // Shutdown will be called from signal handler
   		ConditionWait(m_condShutdown, INFINITE);
#endif
      }
	}
	else
	{
		ConditionWait(m_condShutdown, INFINITE);
		// On Win32, Shutdown() will be called by service control handler
#ifndef _WIN32
		Shutdown();
#endif
	}
	return THREAD_OK;
}

/**
 * Initiate server shutdown
 */
void InitiateShutdown()
{
#ifdef _WIN32
	Shutdown();
#else
	if (IsStandalone())
	{
		Shutdown();
	}
	else
	{
		pthread_kill(m_signalHandlerThread, SIGTERM);
	}
#endif
}

/**
 *DLL Entry point
 */
#ifdef _WIN32

BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
	if (dwReason == DLL_PROCESS_ATTACH)
		DisableThreadLibraryCalls(hInstance);
	return TRUE;
}

#endif
